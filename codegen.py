#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Target code generation module (optional)
Function: Translate quadruple intermediate code to x86-64 assembly code
"""

from typing import List, Dict, Set
from semantic import Quadruple

class CodeGenerator:
    """Target code generator (x86-64 assembly)"""
    
    def __init__(self, quadruples: List[Quadruple], symbol_table: Dict):
        self.quadruples = quadruples
        self.symbol_table = symbol_table
        self.assembly: List[str] = []  # Assembly code list
        self.label_count = 0           # Label counter
        self.temp_count = 0            # Temporary variable counter
        
        # Register allocation (simplified: use basic registers)
        self.registers = {
            'rax': 'accumulator',
            'rbx': 'base register',
            'rcx': 'counter register',
            'rdx': 'data register',
            'rsi': 'source index',
            'rdi': 'destination index',
            'r8': 'general purpose register 8',
            'r9': 'general purpose register 9',
            'r10': 'general purpose register 10',
            'r11': 'general purpose register 11',
            'r12': 'general purpose register 12',
            'r13': 'general purpose register 13',
            'r14': 'general purpose register 14',
            'r15': 'general purpose register 15'
        }
        
        # Variable to register mapping
        self.var_to_reg: Dict[str, str] = {}
        # Register usage status
        self.reg_used: Dict[str, bool] = {reg: False for reg in self.registers}
    
    def generate(self) -> List[str]:
        """Generate assembly code"""
        self._generate_header()
        
        for quad in self.quadruples:
            self._generate_quad(quad)
        
        self._generate_footer()
        
        return self.assembly
    
    def _generate_header(self):
        """Generate assembly header"""
        self.assembly.extend([
            "; =========================================",
            "; x86-64 Assembly Code Generated by Simple C Compiler",
            "; Target Platform: Linux x86-64",
            "; Calling Convention: System V AMD64 ABI",
            "; =========================================",
            "",
            "section .data",
            "    ; Data section"
        ])
        
        # Allocate storage for all variables (including temporaries)
        for name, info in self.symbol_table.items():
            var_type = info.get('type', 'int')
            is_temp = info.get('is_temp', False)
            comment = f"{var_type} type variable" if not is_temp else f"{var_type} type temporary variable"
            self.assembly.append(f"    {name} dq 0  ; {comment}")
        
        self.assembly.extend([
            "",
            "section .bss",
            "    ; Uninitialized data section",
            "    ; (none for now)",
            "",
            "section .text",
            "    global _start",
            "",
            "_start:",
            "    ; Program entry point",
            "    push rbp",
            "    mov rbp, rsp",
            ""
        ])
    
    def _generate_footer(self):
        """Generate assembly footer"""
        self.assembly.extend([
            "",
            "    ; Program exit",
            "    mov rsp, rbp",
            "    pop rbp",
            "    mov rax, 60     ; sys_exit",
            "    xor rdi, rdi    ; exit code 0",
            "    syscall",
            ""
        ])
    
    def _generate_quad(self, quad: Quadruple):
        """Generate assembly code for a single quadruple"""
        op = quad.op
        arg1 = quad.arg1
        arg2 = quad.arg2
        result = quad.result
        
        # Add comment
        self.assembly.append(f"    ; {quad}")
        
        if op == "=":
            # Assignment operation
            self._generate_assignment(arg1, result)
        
        elif op in ["+", "-", "*", "/"]:
            # Arithmetic operation
            self._generate_arithmetic(op, arg1, arg2, result)
        
        elif op in ["==", "!=", ">", "<", ">=", "<="]:
            # Relational operation
            self._generate_relation(op, arg1, arg2, result)
        
        elif op.startswith("j"):
            # Jump instruction
            self._generate_jump(op, arg1, arg2, result)
        
        elif op == "jump":
            # Unconditional jump
            self.assembly.append(f"    jmp {result}")
        
        elif op == "label":
            # Label definition
            self.assembly.append(f"{result}:")
        
        else:
            # Unknown operation
            self.assembly.append(f"    ; Unknown operation: {op}")
    
    def _generate_assignment(self, source, dest):
        """Generate assignment assembly code"""
        if isinstance(source, int):
            # Constant assignment
            self.assembly.append(f"    mov qword [{dest}], {source}")
        elif isinstance(source, str):
            # Variable to variable assignment
            if source in self.symbol_table and dest in self.symbol_table:
                self.assembly.append(f"    mov rax, qword [{source}]")
                self.assembly.append(f"    mov qword [{dest}], rax")
            else:
                # Temporary variable or register
                self.assembly.append(f"    ; Assignment: {dest} = {source}")
        else:
            self.assembly.append(f"    ; Cannot process assignment: {dest} = {source}")
    
    def _generate_arithmetic(self, op, arg1, arg2, result):
        """Generate arithmetic operation assembly code"""
        # Load first operand to rax
        if isinstance(arg1, int):
            self.assembly.append(f"    mov rax, {arg1}")
        elif isinstance(arg1, str):
            self.assembly.append(f"    mov rax, qword [{arg1}]")
        else:
            self.assembly.append(f"    ; Cannot process operand1: {arg1}")
            return
        
        # Load second operand to rbx (if needed)
        if arg2 is not None:
            if isinstance(arg2, int):
                self.assembly.append(f"    mov rbx, {arg2}")
            elif isinstance(arg2, str):
                self.assembly.append(f"    mov rbx, qword [{arg2}]")
            else:
                self.assembly.append(f"    ; Cannot process operand2: {arg2}")
                return
        
        # Generate operation instruction
        if op == "+":
            if arg2 is not None:
                self.assembly.append("    add rax, rbx")
            else:
                self.assembly.append("    ; Error: Addition needs two operands")
        elif op == "-":
            if arg2 is not None:
                self.assembly.append("    sub rax, rbx")
            else:
                self.assembly.append("    ; Error: Subtraction needs two operands")
        elif op == "*":
            if arg2 is not None:
                self.assembly.append("    imul rax, rbx")
            else:
                self.assembly.append("    ; Error: Multiplication needs two operands")
        elif op == "/":
            if arg2 is not None:
                self.assembly.extend([
                    "    xor rdx, rdx      ; Clear rdx (upper part of dividend)",
                    "    idiv rbx          ; Signed division: rdx:rax / rbx"
                ])
            else:
                self.assembly.append("    ; Error: Division needs two operands")
        else:
            self.assembly.append(f"    ; Unknown arithmetic operation: {op}")
            return
        
        # Save result
        if result in self.symbol_table:
            self.assembly.append(f"    mov qword [{result}], rax")
        else:
            self.assembly.append(f"    ; Result storage: {result}")
    
    def _generate_relation(self, op, arg1, arg2, result):
        """Generate relational operation assembly code"""
        # Load operands
        if isinstance(arg1, int):
            self.assembly.append(f"    mov rax, {arg1}")
        elif isinstance(arg1, str):
            self.assembly.append(f"    mov rax, qword [{arg1}]")
        
        if isinstance(arg2, int):
            self.assembly.append(f"    mov rbx, {arg2}")
        elif isinstance(arg2, str):
            self.assembly.append(f"    mov rbx, qword [{arg2}]")
        
        # Comparison operation
        self.assembly.append("    cmp rax, rbx")
        
        # Generate conditional code based on operation
        cond_map = {
            "==": "e",  # equal
            "!=": "ne", # not equal
            ">": "g",   # greater (signed)
            "<": "l",   # less (signed)
            ">=": "ge", # greater or equal
            "<=": "le"  # less or equal
        }
        
        if op in cond_map:
            cond = cond_map[op]
            # Convert result (0 or 1)
            label_true = f".L{self.label_count}_true"
            label_end = f".L{self.label_count}_end"
            self.label_count += 1
            
            self.assembly.extend([
                f"    j{cond} {label_true}  ; If condition is true",
                "    mov rax, 0           ; Condition false, result is 0",
                f"    jmp {label_end}",
                f"{label_true}:",
                "    mov rax, 1           ; Condition true, result is 1",
                f"{label_end}:"
            ])
            
            # Save result
            if result in self.symbol_table:
                self.assembly.append(f"    mov qword [{result}], rax")
        else:
            self.assembly.append(f"    ; Unknown relational operation: {op}")
    
    def _generate_jump(self, op, arg1, arg2, target):
        """Generate conditional jump assembly code"""
        if op == "jump":
            # Unconditional jump
            self.assembly.append(f"    jmp {target}")
            return
        
        # Conditional jump
        if arg1 is None or arg2 is None:
            # Simple conditional jump (based on single value)
            if isinstance(arg1, str):
                self.assembly.append(f"    mov rax, qword [{arg1}]")
                self.assembly.append("    test rax, rax")
            
            # Generate jump based on condition
            if op == "j!=":
                self.assembly.append(f"    jnz {target}")
            elif op == "j==":
                self.assembly.append(f"    jz {target}")
            else:
                self.assembly.append(f"    ; Unknown jump condition: {op}")
        else:
            # Jump based on comparison
            if isinstance(arg1, int):
                self.assembly.append(f"    mov rax, {arg1}")
            elif isinstance(arg1, str):
                self.assembly.append(f"    mov rax, qword [{arg1}]")
            
            if isinstance(arg2, int):
                self.assembly.append(f"    mov rbx, {arg2}")
            elif isinstance(arg2, str):
                self.assembly.append(f"    mov rbx, qword [{arg2}]")
            
            self.assembly.append("    cmp rax, rbx")
            
            # Map jump condition
            jump_map = {
                "j==": "je",
                "j!=": "jne",
                "j>": "jg",
                "j<": "jl",
                "j>=": "jge",
                "j<=": "jle",
                "j!<": "jnl",  # not less (>=)
                "j!>": "jng"   # not greater (<=)
            }
            
            if op in jump_map:
                self.assembly.append(f"    {jump_map[op]} {target}")
            else:
                self.assembly.append(f"    ; Unknown jump: {op}")
    
    def save_assembly(self, filename: str):
        """Save assembly code to file"""
        with open(filename, 'w', encoding='utf-8') as f:
            for line in self.assembly:
                f.write(line + '\n')
        print(f"Assembly code saved to: {filename}")
    
    def print_assembly(self):
        """Print assembly code"""
        print("Generated x86-64 Assembly Code:")
        print("=" * 60)
        for line in self.assembly:
            print(line)
        print("=" * 60)


def test_codegen():
    """Test code generator"""
    # Create test quadruples
    test_quads = [
        Quadruple("=", 5, None, "a"),
        Quadruple("=", 3, None, "b"),
        Quadruple("+", "a", "b", "t1"),
        Quadruple("=", "t1", None, "c"),
        Quadruple(">", "c", 7, "t2"),
        Quadruple("j!=", "t2", 0, "L1"),
        Quadruple("=", 0, None, "result"),
        Quadruple("jump", None, None, "L2"),
        Quadruple("label", None, None, "L1"),
        Quadruple("=", 1, None, "result"),
        Quadruple("label", None, None, "L2"),
    ]
    
    # Create symbol table
    symbol_table = {
        "a": {"type": "int"},
        "b": {"type": "int"},
        "c": {"type": "int"},
        "result": {"type": "int"},
        "t1": {"type": "int", "is_temp": True},
        "t2": {"type": "int", "is_temp": True}
    }
    
    print("Testing Code Generator")
    print("=" * 60)
    
    generator = CodeGenerator(test_quads, symbol_table)
    assembly = generator.generate()
    generator.print_assembly()
    
    # Save to file
    generator.save_assembly("test.asm")
    
    print("\nAssembly Code Information:")
    print("1. Use NASM syntax")
    print("2. Target Platform: Linux x86-64")
    print("3. Calling Convention: System V AMD64 ABI")
    print("4. Need NASM and ld for assembly and linking")
    print("=" * 60)


if __name__ == "__main__":
    test_codegen()
